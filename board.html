<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Quidditch Board Live</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=IM+Fell+English+SC&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0a0b0e; --fg:#e8ecf6;
      --text-normal:#e8ecf6; --text-muted:#b6bed6;
      --background-secondary:#131621; --background-tertiary:#1b2140;
      --interactive-normal:#2a2f44;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:'IM Fell English SC',serif}
    .wrap{min-height:100%;display:grid;place-items:start center;padding:12px;box-sizing:border-box}
    .frame{width:100%;max-width:1600px;position:relative}
    .controls{margin:14px auto 0; width:1600px; background:var(--background-secondary); border-radius:6px; padding:10px;}
    .controls-row{display:flex; align-items:center; gap:12px; padding-bottom:8px; border-bottom:1px solid var(--background-tertiary); margin-bottom:8px;}
    .toggle{display:flex; align-items:center; gap:8px; cursor:pointer; color:var(--text-normal);}
    .btn{padding:6px 12px; border:0; border-radius:6px; background:var(--interactive-normal); color:var(--text-normal); font-size:14px; cursor:pointer;}
    .badge{display:inline-block; width:1rem; height:1rem; border-radius:50%;}
    .notice{position:fixed; inset:auto 12px 12px auto; background:#222; color:#fff; padding:6px 10px; border-radius:6px; font:12px/1.3 system-ui;}
  </style>
</head>
<body>
  <div class="wrap"><div class="frame"><div id="board-root"></div></div></div>

  <!-- React UMD -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Firebase compat (CDN) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <script>
    /*** CONFIG ***/
    const SPRITE_PATH = "images/quidditchboard";
    const ROOM_ID = "main";                 // single room
    const urlRole = new URLSearchParams(location.search).get("role");
    const ROLE = (urlRole === "control") ? "control" : "view";

    // Your Firebase project (as provided)
    const firebaseConfig = {
      apiKey: "AIzaSyD5mJAchcPP61x--oslD2y-tojorp3ysw8",
      authDomain: "league7overlay.firebaseapp.com",
      projectId: "league7overlay",
      storageBucket: "league7overlay.firebasestorage.app",
      messagingSenderId: "126648845416",
      appId: "1:126648845416:web:06be2078b0c95bbb97a7dd",
      measurementId: "G-QW2NG2BNF9"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const docRef = db.collection("quidditchBoard").doc(ROOM_ID);

    /*** AUTH (anonymous) â€” keeps your existing rule happy ***/
    let authed = false;
    function showNotice(msg) {
      let n = document.querySelector('.notice');
      if (!n) { n = document.createElement('div'); n.className='notice'; document.body.appendChild(n); }
      n.textContent = msg;
      clearTimeout(n._t);
      n._t = setTimeout(()=> n.remove(), 3000);
    }
    function requireAuth() {
      return auth.signInAnonymously()
        .then(() => { authed = true; })
        .catch(err => { console.error(err); showNotice('Auth error. Check Firebase setup.'); });
    }

    /*** BOARD CONSTANTS (your code) ***/
    const SCALE = 4;
    const FIELD_WIDTH = 400 * SCALE;
    const FIELD_HEIGHT = 140 * SCALE;
    const MAX_HEIGHT = 120 * SCALE;
    const KEEPER_PKICK_RADIUS = 35 * SCALE; 
    const SEEKER_BUMP_RADIUS = 5 * SCALE; 
    const CHASER_PASS_RADIUS = 50 * SCALE; 
    const BEATER_INTERCEPT_RADIUS = 50 * SCALE; 

    /*** UTILS ***/
    const nowTs = () => Date.now();
    const debounce = (fn, ms) => { let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; };

    /*** REACT COMPONENT ***/
    const QuiddichBoard = () => {
      const canEdit = ROLE === "control";

      const CENTER_X = FIELD_WIDTH / 2;
      const CENTER_Y = FIELD_HEIGHT / 2;
      const OFFSET_X = 50 * SCALE;
      const END_OFFSET = 40 * SCALE;

      const rolePositions = {
        home: {
          'Keeper': { x: END_OFFSET, y: CENTER_Y, z: MAX_HEIGHT/2-20 },
          'Beater': { x: CENTER_X - OFFSET_X*2, y: CENTER_Y, z: MAX_HEIGHT/2-20 },
          'Seeker': { x: CENTER_X, y: FIELD_HEIGHT - (30 * SCALE), z: MAX_HEIGHT/2+30 },
          'Chaser 1': { x: CENTER_X - (OFFSET_X/2), y: CENTER_Y - (20 * SCALE), z: MAX_HEIGHT/2-40 },
          'Chaser 2': { x: CENTER_X-40 - (OFFSET_X/2), y: CENTER_Y, z: MAX_HEIGHT/2-40 },
          'Chaser 3': { x: CENTER_X - (OFFSET_X/2), y: CENTER_Y + (20 * SCALE), z: MAX_HEIGHT/2-40 }
        },
        away: {
          'Keeper': { x: FIELD_WIDTH - END_OFFSET, y: CENTER_Y, z: MAX_HEIGHT/2-20 },
          'Beater': { x: CENTER_X + OFFSET_X*2, y: CENTER_Y, z: MAX_HEIGHT/2-20 },
          'Seeker': { x: CENTER_X, y: 30 * SCALE, z: MAX_HEIGHT/2+30 },
          'Chaser 1': { x: CENTER_X + (OFFSET_X/2), y: CENTER_Y - (20 * SCALE), z: MAX_HEIGHT/2-40 },
          'Chaser 2': { x: CENTER_X+40 + (OFFSET_X/2), y: CENTER_Y, z: MAX_HEIGHT/2-40 },
          'Chaser 3': { x: CENTER_X + (OFFSET_X/2), y: CENTER_Y + (20 * SCALE), z: MAX_HEIGHT/2-40 }
        }
      };

      // STATE
      const [players, setPlayers] = React.useState({ home: [], away: [] });
      const [radiusVisibility, setRadiusVisibility] = React.useState({
        keeperPKick: false, seekerBump: false, chaserPass: false, beaterIntercept: false
      });

      // Drawing
      const [isDrawingMode, setIsDrawingMode] = React.useState(false);
      const [isDrawing, setIsDrawing] = React.useState(false);
      const [drawings, setDrawings] = React.useState([]); // [{ path:[{x,y}], color }]
      const canvasRef = React.useRef(null);
      const currentPathRef = React.useRef([]);

      // Drag
      const draggedPlayerRef = React.useRef(null);

      // init default pieces
      React.useEffect(() => {
        const defHome = ["Keeper","Beater","Seeker","Chaser 1","Chaser 2","Chaser 3"].map((role, id) => ({
          id: id + 1, name: "", role, team: "home", ...rolePositions.home[role]
        }));
        const defAway = ["Keeper","Beater","Seeker","Chaser 1","Chaser 2","Chaser 3"].map((role, id) => ({
          id: id + 7, name: "", role, team: "away", ...rolePositions.away[role]
        }));
        setPlayers({ home: defHome, away: defAway });
      }, []);

      // draw all saved strokes to canvas
      const redrawCanvas = React.useCallback(() => {
        const c = canvasRef.current; if (!c) return;
        const ctx = c.getContext("2d");
        ctx.clearRect(0, 0, FIELD_WIDTH, FIELD_HEIGHT);
        drawings.forEach(d => {
          const p = d.path; if (!p || p.length < 2) return;
          ctx.beginPath(); ctx.strokeStyle = d.color || "#ffbd00";
          ctx.lineWidth = 3; ctx.lineCap = "round"; ctx.lineJoin = "round";
          ctx.moveTo(p[0].x, p[0].y);
          for (let i=1;i<p.length;i++) ctx.lineTo(p[i].x, p[i].y);
          ctx.stroke();
        });
      }, [drawings]);

      React.useEffect(() => { redrawCanvas(); }, [redrawCanvas, players]);

      // icons
      const getRoleIcon = (role, team) => {
        const baseRole = role.replace(/ \d+$/, "").toLowerCase();
        const suffix = team === "away" ? "_gold" : "";
        return `${SPRITE_PATH}/${baseRole}${suffix}.png`;
      };

      // drawing handlers
      const startDrawing = (e) => {
        if (!isDrawingMode) return; // auth already done globally
        const rect = canvasRef.current.getBoundingClientRect();
        const x = e.clientX - rect.left, y = e.clientY - rect.top;
        setIsDrawing(true);
        currentPathRef.current = [{ x, y }];
      };
      const draw = (e) => {
        if (!isDrawingMode || !isDrawing) return;
        const rect = canvasRef.current.getBoundingClientRect();
        const x = e.clientX - rect.left, y = e.clientY - rect.top;
        currentPathRef.current.push({ x, y });

        // live preview on top
        const c = canvasRef.current, ctx = c.getContext("2d");
        ctx.clearRect(0, 0, FIELD_WIDTH, FIELD_HEIGHT);
        drawings.forEach(d => {
          const p = d.path; if (!p || p.length < 2) return;
          ctx.beginPath(); ctx.strokeStyle = d.color || "#ffbd00";
          ctx.lineWidth = 3; ctx.lineCap = "round"; ctx.lineJoin = "round";
          ctx.moveTo(p[0].x, p[0].y);
          for (let i=1;i<p.length;i++) ctx.lineTo(p[i].x, p[i].y);
          ctx.stroke();
        });
        const p2 = currentPathRef.current;
        if (p2.length > 1) {
          ctx.beginPath(); ctx.strokeStyle = "#ffbd00"; ctx.lineWidth = 3;
          ctx.lineCap = "round"; ctx.lineJoin = "round";
          ctx.moveTo(p2[0].x, p2[0].y);
          for (let i=1;i<p2.length;i++) ctx.lineTo(p2[i].x, p2[i].y);
          ctx.stroke();
        }
      };
      const stopDrawing = () => {
        if (isDrawing && isDrawingMode) {
          const newStroke = { path: currentPathRef.current.slice(), color: "#ffbd00" };
          const next = [...drawings, newStroke];
          setDrawings(next);
          publishDrawings(next);
        }
        setIsDrawing(false);
      };
      const clearCanvas = () => {
        const c = canvasRef.current, ctx = c.getContext("2d");
        ctx.clearRect(0, 0, FIELD_WIDTH, FIELD_HEIGHT);
        setDrawings([]);
        publishDrawings([]);
      };

      // drag handlers
      const handleDragStart = (e, player) => {
        draggedPlayerRef.current = player;
        const ghost = new Image();
        ghost.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
        e.dataTransfer.setDragImage(ghost, 0, 0);
      };
      const handleDragOver = (e) => {
        e.preventDefault();
        if (!draggedPlayerRef.current) return;
        const rect = e.currentTarget.getBoundingClientRect();
        const x = Math.max(0, Math.min(FIELD_WIDTH, e.clientX - rect.left));
        const y = Math.max(0, Math.min(FIELD_HEIGHT, e.clientY - rect.top));
        const id = draggedPlayerRef.current.id;
        const team = draggedPlayerRef.current.team;
        setPlayers(prev => ({
          ...prev,
          [team]: prev[team].map(p => p.id === id ? { ...p, x, y } : p)
        }));
      };
      const handleDragEnd = () => {
        draggedPlayerRef.current = null;
        publishPlayers();
      };

      // Firestore publish (client-side: only control shows buttons, but both roles are authed)
      const publishPlayers = debounce(() => {
        docRef.set({ players: { players, updatedAt: nowTs() } }, { merge: true }).catch(console.error);
      }, 100);

      const publishDrawings = debounce((nextDrawings) => {
        docRef.set({ drawings: { drawings: nextDrawings, updatedAt: nowTs() } }, { merge: true }).catch(console.error);
      }, 100);

      const publishRanges = debounce((nextRanges) => {
        docRef.set({ ranges: { radiusVisibility: nextRanges, updatedAt: nowTs() } }, { merge: true }).catch(console.error);
      }, 100);

      // Firestore subscribe
      React.useEffect(() => {
        const unsub = docRef.onSnapshot(snap => {
          const data = snap.data() || {};
          if (data.players && data.players.players && !draggedPlayerRef.current) {
            setPlayers(data.players.players);
          }
          if (data.drawings && Array.isArray(data.drawings.drawings) && !isDrawing) {
            setDrawings(data.drawings.drawings);
          }
          if (data.ranges && data.ranges.radiusVisibility) {
            setRadiusVisibility(prev => ({ ...prev, ...data.ranges.radiusVisibility }));
          }
        }, console.error);
        return unsub;
      }, [isDrawing]);

      // UI bits
      const RoleCircle = ({ player, radius, color, visible }) =>
        React.createElement("div", {
          style:{
            position:"absolute", left:`${player.x}px`, top:`${player.y}px`,
            width:`${radius*2}px`, height:`${radius*2}px`, borderRadius:"50%",
            backgroundColor:`${color}33`, border:`1px solid ${color}4D`,
            transform:"translate(-50%, -50%)", pointerEvents:"none",
            transition:"opacity .3s", opacity: visible ? 1 : 0
          }
        });

      const Controls = () => {
        if (ROLE !== "control") return null; // only show on controller
        const toggle = (id) => {
          const next = { ...radiusVisibility, [id]: !radiusVisibility[id] };
          setRadiusVisibility(next);
          publishRanges(next);
        };
        return React.createElement("div", { className:"controls" },
          React.createElement("div", { className:"controls-row" },
            React.createElement("label", { className:"toggle" },
              React.createElement("input", {
                type:"checkbox",
                checked: isDrawingMode,
                onChange: ()=> setIsDrawingMode(p=>!p)
              }),
              "Enable/Disable drawing mode"
            ),
            React.createElement("button", { className:"btn", onClick: clearCanvas }, "ðŸ§¹ Clear current drawing")
          ),
          // range toggles
          [["keeperPKick","#FF0000","Show power kick range on Keepers (r=35m)"],
           ["seekerBump","#e8c500","Show bump distance on Seekers (r=5m)"],
           ["chaserPass","#85ae6f","Show Quaffle pass range on Chasers (r=50m)"],
           ["beaterIntercept","#4169E1","Show Bludger intercept distance on Beaters (r=50m)"]
          ].map(([id,color,label]) =>
            React.createElement("label", { key:id, className:"toggle", style:{ padding:"4px 0" } },
              React.createElement("input", {
                type:"checkbox",
                checked: !!radiusVisibility[id],
                onChange: ()=> toggle(id)
              }),
              React.createElement("span", { className:"badge", style:{ backgroundColor:`${color}33`, border:`1px solid ${color}` } }),
              label
            )
          )
        );
      };

      const PlayField = () => (
        React.createElement("div", { style:{ width:`${FIELD_WIDTH}px`, height:`${FIELD_HEIGHT}px`, position:"relative" } },
          // background
          React.createElement("div", {
            style:{
              width:"100%", height:"100%",
              backgroundImage:`url("${SPRITE_PATH}/qpitch.png")`,
              backgroundSize:"100% 100%", backgroundPosition:"center", backgroundRepeat:"no-repeat",
              position:"absolute", top:0, left:0, zIndex:0
            }
          }),
          // canvas
          React.createElement("canvas", {
            ref:canvasRef, width:FIELD_WIDTH, height:FIELD_HEIGHT,
            onMouseDown: isDrawingMode ? startDrawing : null,
            onMouseMove: isDrawingMode ? draw : null,
            onMouseUp:   isDrawingMode ? stopDrawing : null,
            onMouseLeave:isDrawingMode ? stopDrawing : null,
            style:{
              position:"absolute", top:0, left:0, zIndex:1,
              pointerEvents: isDrawingMode ? "auto" : "none",
              cursor: isDrawingMode ? "crosshair" : "default"
            }
          }),
          // pieces
          React.createElement("div", {
            style:{ position:"absolute", top:0, left:0, width:"100%", height:"100%", zIndex:2, pointerEvents:"auto" },
            onDragOver:(e)=>{ e.preventDefault(); handleDragOver(e); }
          },
            // ranges
            Object.values(players).flat().map(player => {
              const arr = [];
              if (player.role === "Keeper") arr.push(React.createElement(RoleCircle,{key:`rk-${player.id}`,player,radius:KEEPER_PKICK_RADIUS,color:"#ec2525",visible:radiusVisibility.keeperPKick}));
              else if (player.role === "Seeker") arr.push(React.createElement(RoleCircle,{key:`rs-${player.id}`,player,radius:SEEKER_BUMP_RADIUS,color:"#e8c500",visible:radiusVisibility.seekerBump}));
              else if (player.role.startsWith("Chaser")) arr.push(React.createElement(RoleCircle,{key:`rc-${player.id}`,player,radius:CHASER_PASS_RADIUS,color:"#a1d187",visible:radiusVisibility.chaserPass}));
              else if (player.role === "Beater") arr.push(React.createElement(RoleCircle,{key:`rb-${player.id}`,player,radius:BEATER_INTERCEPT_RADIUS,color:"#2557ec",visible:radiusVisibility.beaterIntercept}));
              return arr;
            }),
            // icons
            Object.values(players).flat().map(player =>
              React.createElement("div", {
                key:`icon-${player.id}`,
                draggable: !isDrawingMode,
                onDragStart:(e)=> handleDragStart(e, player),
                onDragEnd: ()=> handleDragEnd(),
                style:{
                  position:"absolute", left:`${player.x}px`, top:`${player.y}px`,
                  transform:"translate(-50%, -50%)",
                  cursor: !isDrawingMode ? "move" : "default",
                  width:"2rem", height:"2rem", zIndex:2
                }
              },
                React.createElement("img", {
                  src: getRoleIcon(player.role, player.team),
                  alt: player.role,
                  style:{ width:"100%", height:"100%", objectFit:"contain" }
                })
              )
            ),
            // labels
            Object.values(players).flat().map(player =>
              React.createElement("div", {
                key:`name-${player.id}`,
                style:{
                  position:"absolute", left:`${player.x}px`, top:`${player.y + 20}px`,
                  transform:"translate(-50%, 0)", color:"white", fontSize:"0.8em",
                  whiteSpace:"nowrap", pointerEvents:"none", textAlign:"center"
                }
              }, player.role)
            )
          )
        )
      );

      return React.createElement(React.Fragment, null,
        React.createElement(PlayField),
        ROLE === "control" ? React.createElement(Controls) : null
      );
    };

    /*** BOOTSTRAP: auth first, then mount ***/
    (async function boot(){
      await requireAuth();  // satisfies your current Firestore rule
      const el = document.getElementById("board-root");
      if (ReactDOM.createRoot) ReactDOM.createRoot(el).render(React.createElement(QuiddichBoard));
      else ReactDOM.render(React.createElement(QuiddichBoard), el);
      showNotice(ROLE === 'control' ? 'Control mode (signed in anon)' : 'View mode (signed in anon)');
    })();
  </script>
</body>
</html>
